// +build opentui

package mailos

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	opentui "github.com/sst/opentui/packages/go"
)

const (
	// UI dimensions
	defaultWidth  = 80
	defaultHeight = 24
	
	// Colors
	colorBackground = 0.05
	colorPrompt     = 0.8
	colorInput      = 1.0
	colorSelected   = 0.7
	colorHelp       = 0.4
	colorTitle      = 0.9
)

// OpenTUIModel represents the state of the OpenTUI interface
type OpenTUIModel struct {
	renderer     *opentui.Renderer
	buffer       *opentui.Buffer
	input        string
	cursorPos    int
	suggestions  []AISuggestion
	commands     []command
	files        []string
	references   []referenceItem
	accounts     []AccountConfig
	emails       []*Email
	selectedEmail *Email
	mode         inputMode
	selectedIdx  int
	showList     bool
	width        int
	height       int
	result       string
	err          error
	quitting     bool
	showingAccountSelector bool
	showingEmailList bool
	showingEmailContent bool
}

// NewOpenTUIModel creates a new OpenTUI model
func NewOpenTUIModel() *OpenTUIModel {
	// Try to fetch last 50 emails for display
	emails := fetchLastEmails(50)
	
	return &OpenTUIModel{
		width:       defaultWidth,
		height:      defaultHeight,
		suggestions: GetDefaultAISuggestions(),
		emails:      emails,
		commands:    getDefaultCommands(),
		references:  getReferencesItems(emails),
		mode:        normalMode,
		selectedIdx: 0,
		showList:    true,
		input:       "",
		cursorPos:   0,
	}
}

// Init initializes the OpenTUI renderer
func (m *OpenTUIModel) Init() error {
	// Create renderer
	m.renderer = opentui.NewRenderer(m.width, m.height)
	
	// Enable mouse support
	m.renderer.EnableMouse(true)
	
	// Create buffer
	m.buffer = opentui.NewBuffer(m.width, m.height, false, opentui.WidthMethodUnicode)
	
	return nil
}

// Close cleans up OpenTUI resources
func (m *OpenTUIModel) Close() {
	if m.renderer != nil {
		m.renderer.DisableMouse()
		m.renderer.Close()
	}
	if m.buffer != nil {
		m.buffer.Close()
	}
}

// Update handles input events and updates the model
func (m *OpenTUIModel) Update(key string) {
	switch key {
	case "ctrl+c":
		m.quitting = true
		m.err = fmt.Errorf("cancelled")
		
	case "ctrl+d":
		if m.input == "" {
			m.quitting = true
			m.err = fmt.Errorf("exit")
		}
		
	case "escape":
		if m.showingEmailContent {
			m.showingEmailContent = false
			m.selectedEmail = nil
		} else if m.showingEmailList {
			m.showingEmailList = false
			m.mode = normalMode
			m.selectedIdx = 0
		} else if m.showingAccountSelector {
			m.showingAccountSelector = false
			m.mode = normalMode
			m.selectedIdx = 0
		} else if m.showList {
			m.showList = false
			m.mode = normalMode
			m.selectedIdx = 0
		}
		
	case "tab":
		if !m.showingAccountSelector && !m.showingEmailContent {
			// Fetch all configured accounts
			config, _ := LoadConfig()
			m.accounts = GetAllAccounts(config)
			if len(m.accounts) > 0 {
				m.showingAccountSelector = true
				m.selectedIdx = 0
			}
		} else if m.mode == fileMode && m.selectedIdx < len(m.references) {
			// Autocomplete selected reference
			m.autocompleteReference()
		}
		
	case "up":
		if m.showList && m.selectedIdx > 0 {
			m.selectedIdx--
		}
		
	case "down":
		if m.showList {
			maxIdx := m.getMaxIndex()
			if m.selectedIdx < maxIdx-1 {
				m.selectedIdx++
			}
		}
		
	case "enter":
		m.handleEnter()
		
	case "backspace":
		if m.cursorPos > 0 {
			m.input = m.input[:m.cursorPos-1] + m.input[m.cursorPos:]
			m.cursorPos--
			m.updateMode()
		}
		
	case "left":
		if m.cursorPos > 0 {
			m.cursorPos--
		}
		
	case "right":
		if m.cursorPos < len(m.input) {
			m.cursorPos++
		}
		
	default:
		// Handle regular character input
		if len(key) == 1 {
			m.input = m.input[:m.cursorPos] + key + m.input[m.cursorPos:]
			m.cursorPos++
			m.updateMode()
		}
	}
}

// updateMode updates the input mode based on current input
func (m *OpenTUIModel) updateMode() {
	if strings.Contains(m.input, "@") {
		if m.mode != fileMode {
			m.mode = fileMode
			m.references = getReferencesItems(m.emails)
			m.showList = true
			m.selectedIdx = 0
		} else {
			// Filter references
			atIndex := strings.LastIndex(m.input, "@")
			if atIndex >= 0 && atIndex < len(m.input)-1 {
				partial := m.input[atIndex+1:]
				m.references = filterReferences(getReferencesItems(m.emails), partial)
				m.showList = len(m.references) > 0
			}
		}
	} else if strings.HasPrefix(m.input, "/") {
		m.mode = commandMode
		if len(m.input) == 1 {
			m.commands = getDefaultCommands()
			m.showList = true
			m.selectedIdx = 0
		} else {
			partial := m.input[1:]
			m.commands = filterCommands(getDefaultCommands(), partial)
			m.showList = len(m.commands) > 0
		}
	} else {
		m.mode = normalMode
		if m.input == "" {
			m.suggestions = GetDefaultAISuggestions()
			m.showList = true
			m.selectedIdx = 0
		} else {
			m.suggestions = filterSuggestions(GetDefaultAISuggestions(), m.input)
			m.showList = len(m.suggestions) > 0
		}
	}
}

// getMaxIndex returns the maximum index for the current mode
func (m *OpenTUIModel) getMaxIndex() int {
	switch m.mode {
	case normalMode:
		return len(m.suggestions)
	case commandMode:
		return len(m.commands)
	case fileMode:
		return len(m.references)
	default:
		return 0
	}
}

// handleEnter processes the enter key
func (m *OpenTUIModel) handleEnter() {
	if m.showingEmailList && m.selectedIdx < len(m.emails) {
		m.selectedEmail = m.emails[m.selectedIdx]
		m.showingEmailContent = true
		return
	}
	
	if m.showingAccountSelector {
		if m.selectedIdx < len(m.accounts) {
			selectedEmail := m.accounts[m.selectedIdx].Email
			_, err := InitializeMailSetup(selectedEmail)
			if err == nil {
				m.showingAccountSelector = false
				m.mode = normalMode
				m.selectedIdx = 0
			}
		}
		return
	}
	
	if m.showList {
		switch m.mode {
		case normalMode:
			if m.selectedIdx < len(m.suggestions) {
				m.result = m.suggestions[m.selectedIdx].Command
				m.quitting = true
			}
		case commandMode:
			if m.selectedIdx < len(m.commands) {
				m.result = "/" + m.commands[m.selectedIdx].name
				m.quitting = true
			}
		case fileMode:
			m.autocompleteReference()
		}
	} else {
		// Submit input
		input := strings.TrimSpace(m.input)
		if input != "" {
			m.result = input
			m.quitting = true
		}
	}
}

// autocompleteReference handles reference autocompletion
func (m *OpenTUIModel) autocompleteReference() {
	if m.selectedIdx < len(m.references) {
		selectedItem := m.references[m.selectedIdx]
		atIndex := strings.LastIndex(m.input, "@")
		if atIndex >= 0 {
			var newValue string
			if selectedItem.itemType == "email" {
				newValue = m.input[:atIndex+1] + selectedItem.displayName
			} else {
				newValue = m.input[:atIndex+1] + selectedItem.id
			}
			m.input = newValue
			m.cursorPos = len(newValue)
		}
		m.showList = false
		m.mode = normalMode
		m.selectedIdx = 0
	}
}

// Render draws the UI to the buffer
func (m *OpenTUIModel) Render() {
	if m.buffer == nil {
		return
	}
	
	// Clear buffer with background color
	bgColor := opentui.NewRGB(colorBackground, colorBackground, colorBackground*2)
	m.buffer.Clear(bgColor)
	
	// Draw based on current state
	if m.showingEmailContent && m.selectedEmail != nil {
		m.renderEmailContent()
	} else if m.showingAccountSelector {
		m.renderAccountSelector()
	} else {
		m.renderMainUI()
	}
	
	// Get the next buffer and render
	if nextBuffer, err := m.renderer.GetNextBuffer(); err == nil {
		// Copy our buffer content to the renderer's buffer
		// This would need proper implementation based on OpenTUI's API
		m.renderer.Render(false)
	}
}

// renderMainUI renders the main interactive UI
func (m *OpenTUIModel) renderMainUI() {
	y := 1
	
	// Header
	config, _ := LoadConfig()
	if config.Email != "" {
		header := fmt.Sprintf("ðŸ“§ %s | ðŸ¤– %s", config.Email, getFriendlyAIName(config.DefaultAICLI))
		m.buffer.DrawText(header, 2, y, opentui.NewRGB(colorTitle, colorTitle, colorTitle), nil, 0)
		y += 2
	}
	
	// Input prompt
	prompt := "â–¸ "
	m.buffer.DrawText(prompt, 2, y, opentui.NewRGB(colorPrompt, colorPrompt/2, colorPrompt/2), nil, opentui.AttrBold)
	
	// Input field
	m.buffer.DrawText(m.input, 4, y, opentui.White, nil, 0)
	
	// Draw cursor
	opentui.SetCursorPosition(4+m.cursorPos, y, true)
	opentui.SetCursorStyle(opentui.CursorBlock, true)
	
	y += 2
	
	// Show list based on mode
	if m.showList {
		m.renderList(y)
	} else {
		// Help text
		helpText := "Enter: submit | /: commands | @: files & emails | Tab: accounts | Ctrl+C: cancel"
		m.buffer.DrawText(helpText, 2, y, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
	}
}

// renderList renders the suggestion/command/file list
func (m *OpenTUIModel) renderList(startY int) {
	y := startY
	
	switch m.mode {
	case normalMode:
		m.buffer.DrawText("Suggestions (â†‘â†“ to navigate):", 2, y, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
		y += 2
		
		for i, sug := range m.suggestions {
			if i >= 10 {
				break // Limit display
			}
			
			prefix := "  "
			color := opentui.White
			if i == m.selectedIdx {
				prefix = "â–¸ "
				color = opentui.NewRGB(colorSelected, colorSelected, 0)
			}
			
			text := fmt.Sprintf("%s%s", prefix, sug.Title)
			m.buffer.DrawText(text, 2, y+i, color, nil, 0)
		}
		
	case commandMode:
		m.buffer.DrawText("Commands:", 2, y, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
		y += 2
		
		for i, cmd := range m.commands {
			if i >= 10 {
				break
			}
			
			prefix := "  "
			color := opentui.White
			if i == m.selectedIdx {
				prefix = "â–¸ "
				color = opentui.NewRGB(colorSelected, colorSelected, 0)
			}
			
			text := fmt.Sprintf("%s/%s - %s", prefix, cmd.name, cmd.description)
			m.buffer.DrawText(text, 2, y+i, color, nil, 0)
		}
		
	case fileMode:
		m.buffer.DrawText("Files & Emails:", 2, y, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
		y += 2
		
		for i, ref := range m.references {
			if i >= 10 {
				break
			}
			
			prefix := "  "
			color := opentui.White
			if i == m.selectedIdx {
				prefix = "â–¸ "
				color = opentui.NewRGB(colorSelected, colorSelected, 0)
			}
			
			text := fmt.Sprintf("%s%s %s", prefix, ref.icon, ref.displayName)
			m.buffer.DrawText(text, 2, y+i, color, nil, 0)
		}
	}
}

// renderEmailContent renders email content view
func (m *OpenTUIModel) renderEmailContent() {
	if m.selectedEmail == nil {
		return
	}
	
	y := 1
	
	// Header
	m.buffer.DrawText("ðŸ“§ Email Content", 2, y, opentui.NewRGB(colorTitle, colorTitle, colorTitle), nil, opentui.AttrBold)
	y += 1
	m.buffer.DrawText("ESC: Back to list", 2, y, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
	y += 2
	
	// Email details
	m.buffer.DrawText(fmt.Sprintf("From: %s", m.selectedEmail.From), 2, y, opentui.White, nil, 0)
	y++
	m.buffer.DrawText(fmt.Sprintf("Subject: %s", m.selectedEmail.Subject), 2, y, opentui.White, nil, 0)
	y++
	m.buffer.DrawText(fmt.Sprintf("Date: %s", m.selectedEmail.Date.Format("Jan 2, 2006")), 2, y, opentui.White, nil, 0)
	y += 2
	
	// Body (truncated for display)
	body := m.selectedEmail.Body
	if len(body) > 500 {
		body = body[:500] + "..."
	}
	lines := strings.Split(body, "\n")
	for i, line := range lines {
		if y+i >= m.height-2 {
			break
		}
		m.buffer.DrawText(line, 2, y+i, opentui.White, nil, 0)
	}
}

// renderAccountSelector renders the account selection UI
func (m *OpenTUIModel) renderAccountSelector() {
	y := 1
	
	// Header
	m.buffer.DrawText("ðŸ“¬ Select Email Account", 2, y, opentui.NewRGB(colorTitle, colorTitle, colorTitle), nil, opentui.AttrBold)
	y += 2
	
	// Account list
	for i, acc := range m.accounts {
		cursor := "  "
		color := opentui.White
		if i == m.selectedIdx {
			cursor = "â–¸ "
			color = opentui.NewRGB(colorSelected, colorSelected, 0)
		}
		
		text := fmt.Sprintf("%s%s", cursor, acc.Email)
		if acc.Label != "" && acc.Label != "Account" {
			text += fmt.Sprintf(" (%s)", acc.Label)
		}
		
		m.buffer.DrawText(text, 2, y+i, color, nil, 0)
	}
	
	// Help text
	helpY := y + len(m.accounts) + 2
	m.buffer.DrawText("â†‘â†“ Navigate â€¢ Enter: Select â€¢ ESC: Cancel", 2, helpY, opentui.NewRGB(colorHelp, colorHelp, colorHelp), nil, 0)
}

// OpenTUIInteractiveInput provides an interactive input experience using OpenTUI
func OpenTUIInteractiveInput() (string, error) {
	model := NewOpenTUIModel()
	
	// Initialize OpenTUI
	if err := model.Init(); err != nil {
		return "", fmt.Errorf("failed to initialize OpenTUI: %w", err)
	}
	defer model.Close()
	
	// Main event loop
	for !model.quitting {
		// Render the UI
		model.Render()
		
		// Wait for input (simplified - real implementation would need proper event handling)
		// This is a placeholder - OpenTUI would need proper input handling
		time.Sleep(16 * time.Millisecond) // ~60 FPS
		
		// In a real implementation, we'd read keyboard input here
		// and call model.Update(key)
	}
	
	if model.err != nil {
		return "", model.err
	}
	
	return model.result, nil
}

// InteractiveModeWithOpenTUI runs the interactive mode using OpenTUI for input
func InteractiveModeWithOpenTUI() error {
	config, err := LoadConfig()
	if err != nil {
		return fmt.Errorf("failed to load configuration: %v", err)
	}
	
	// Check for slash config
	slashConfig := loadSlashConfig()
	
	// If no AI provider configured, show setup prompt inline
	needsProvider := (config.DefaultAICLI == "" || config.DefaultAICLI == "none") && !hasConfiguredProvider(slashConfig)
	
	// Only show logo during initial setup
	if needsProvider {
		if ShouldShowLogo() {
			DisplayEmailOSLogo()
		}
	}
	
	// Main interactive loop
	for {
		// Get input using OpenTUI
		input, err := OpenTUIInteractiveInput()
		if err != nil {
			if err.Error() == "exit" || err.Error() == "cancelled" {
				fmt.Println("\nGoodbye!")
				return nil
			}
			continue
		}
		
		// Process the input
		input = strings.TrimSpace(input)
		if input == "" {
			continue
		}
		
		// Handle commands
		if strings.HasPrefix(input, "/") {
			if input == "/add-account" {
				if err := handleAddAccount(); err != nil {
					fmt.Printf("Error adding account: %v\n", err)
				}
				continue
			}
			
			if err := executeCommand(input); err != nil {
				if err.Error() == "exit" {
					fmt.Println("\nGoodbye!")
					return nil
				}
				fmt.Printf("Error: %v\n", err)
			}
			// After provider setup, update needsProvider flag
			if needsProvider {
				config, _ = LoadConfig()
				needsProvider = (config.DefaultAICLI == "" || config.DefaultAICLI == "none")
			}
			continue
		}
		
		// Handle file references
		processedInput := input
		if strings.Contains(input, "@") {
			processedInput = processFileReferences(input)
		}
		
		// Execute AI query
		if needsProvider {
			fmt.Println("\nNo AI provider configured. Use /provider to set one up.")
			continue
		}
		
		// Execute the AI query using existing handler
		if err := handleAIQuery(processedInput); err != nil {
			fmt.Printf("Error: %v\n", err)
		}
	}
}